# Namespace

- 쿠버네티스의 클러스터 내에서 리소스를 논리적으로 구분하기 위한 단위
- 하나의 클러스터를 여러 개의 가상 환경처럼 사용할 수 있도록 함
- 동일한 이름의 리소스라도 namespace가 다르면 공존할 수 있음
- `default`, `kube-system`, `kube-public` 등이 기본으로 존재함

## 주요 명령어

```        
# get list of namespace
$ kubectl get namespaces

# create namespace
kubectl create namespace <name>

# apply with namespace
kubectl apply -f service.yaml -n <name>

# check resouces in specific namespace
kubectl get pods -n <name>
```

# ConfigMap

- 애플리케이션이 사용할 환경설정 값을 저장하는 리소스
    - Key-Value 형태의 데이터
- 코드와 설정을 분리하여 환경별 설정 관리가 가능
- pod 내부에 환경 변수, 명령줄 인자, 볼륨 파일 형태로 넣을 수 있음
    - ConfigMap 설정
        ```yaml
        apiVersion: v1
        kind: ConfigMap
        metadata:
            name: app-config
        data:
            DATABASE_URL: "mysql://db-service:3306/mydb"
            LOG_LEVEL: "debug"

        envFrom:
            - configMapRef:
                name: app-config
        ```
    - pod 내
        ```yaml
        envFrom:
            - configMapRef:
                name: app-config    
        ```

# Secret

- 비밀번호, API 키, 인증 토큰 등 민감한 정보를 저장하기 위한 리소스
- ConfigMap과 유사하지만, 데이터가 Base64로 인코딩되어 저장됨
- pod 환경 변수나 볼륨 파일을 통해 전달 가능
    - Secret 설정
        ```yaml
        apiVersion: v1
        kind: Secret
        metadata:
            name: db-secret
        type: Opaque
        data:
            username: YWRtaW4=    # "admin"
            password: c2VjcmV0    # "secret"
        ```
    - pod 내
        ```yaml
        env:
            - name: DB_USER
                valueFrom:
                secretKeyRef:
                    name: db-secret
                    key: username
        ```
> [!NOTE]
> ConfigMap이랑 그래서 뭐가 달라서 보안적 이점이 있음?

- Secret은 API 서버와 노드 레벨에서 특별한 보호 정책이 적용됨
    - RBAC (Role-Based Access Control) 분리 가능
    - API 서버와 통신 시 암호화 (네트워크 구간에서는 노출 X)
    - etcd 저장 시 암호화 가능
- 그래서 pod 내부에서만 접근 가능

# Ingress

- 외부 요청을 클러스터 내부 서비스로 라우팅하는 HTTP/HTTPS의 entry point
- Service가 클러스터 내부 IP를 제공한다면, Ingress는 도메인 기반 접근을 가능하게 함
- Path-based routing, Host-based routing, TLS(HTTPS) 지원
- Ingress Controller가 반드시 필요 - 실제로 동작시키기 위함

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
    name: web-ingress
    annotations:
        nginx.ingress.kubernetes.io/rewrite-target: /
spec:
    rules:
        - host: app.example.com     # Host-based routing
    http:
        paths:
            - path: /               # Path-based routing
        pathType: Prefix
        backend:
            service:
            name: web-service
            port:
                number: 80
```

*위 설정은 `http://app.example.com/` 요청을 `web-service`로 전달함

> [!NOTE]
> Istio와의 관계: https://gruuuuu.hololy.org/cloud/service-mesh-istio/